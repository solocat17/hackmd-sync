# 附錄：你該知道的關鍵字

- 製作：社長 李宗諺、教學 陳泰穎

---

[TOC]

---

## 終端機編譯/執行

預防你某天沒有一個好的IDE(整合開發環境，就是編譯器+編輯器，除了可以打扣還可以run)可以用，你最好學會這個

```typescript=
$ g++ code.cpp
# 這樣他就可以執行了

$ g++ code.cpp -o run
# 這樣他就會編譯code.cpp，並且生成執行檔run.exe在原目錄

$ run
# 這樣他就會執行run.exe

$ run < 1.in
# 這樣他就會執行run，並把1.in作為輸入塞進去

$ run < 1.in > 1.out
# 這樣他就會執行run，並把1.in作為輸入塞進去，最後把結果塞進1.out裡
```

以上是最基本的終端編譯操作，當然可以再加更多參數，例如你想優化執行速度之類的，但這邊礙於篇幅限制先不提

---

## C/C++標頭檔轉換

因為 C++ 繼承了大部分 C 有的語言函式庫，所以原則上同一個標頭檔在 C/C++ 都可以用，但還是稍微說一下他有時候會換一個名字

```typescript=
#include <stdio.h>
//C語言的版本

#include <cstdio>
//C++的版本
```

---

## 萬能標頭檔

大家應該知道你要用什麼東西基本上就得include他的library進來，舉例來說你今天如果想用std::sort，你就得在開頭加上一行#include \<algorithm>，但你很快就會發現你不太想記所有的library的名字。於是乎你就很好奇有沒有所謂萬能標頭檔，也就是你只要記他的名字，其他的都可以忘掉了

```typescript=
#include <bits/stdc++.h>
```
就是他，他超棒，有了它你可以忘掉所有其他標頭檔的名字。但也請在使用時注意到，如果你引用他就相當於引用所有標頭檔(除了一些像是pbds之類的黑魔法)，那這將會是你的編譯時間大幅度提升。換言之，如果你原先只需要引用3,4個標頭檔，但你卻選擇<bits/stdc++.h>的話將會耗費掉許多無謂的時間。請自行斟酌使用

---

## IO優化

通常而言，一個程式在執行的時候輸入輸出是單一操作裡最慢的部分，尤其是在你用cin, cout來吃輸入的時候，因為他在吃輸入的時候不用標記型態，但也因為這樣，cin, cout實在是太香了，我們只好想方法讓他快一點

先講結論，在你的main函數裡面加上兩行code(如下)會讓他快上許多。原理有興趣的再問社幹，礙於篇幅我就不放在這裡了
```typescript=
ios_base::sync_with_stdio(false);
cin.tie(0);
```
另外，盡量不要用endl，他會讓你的程式變很慢，可以的話就換成用'\n'取代，反正都是4個字元，打起來沒差多少~~雖然我都直接#define endl '\n'~~

http://chino.taipei/note-2016-0311C-%E7%9A%84%E8%BC%B8%E5%87%BA%E5%85%A5cin-cout%E5%92%8Cscanf-printf%E8%AA%B0%E6%AF%94%E8%BC%83%E5%BF%AB%EF%BC%9F/

---

## 整行讀取

如果你今天遇到的題目輸入格式超複雜，可以試著先把它當成字串吃進來再對他做處理，好用的函數getline, cin.getline。兩者差異在於能用的對象不一樣，前者只能用在std::string的讀取，後者只能用在char[] (char型態的陣列)

cin.getline()有三個參數，依序為陣列的指標、陣列大小、結束字元，其中結束字元預設為換行，可省略

getline()可以讀取整行成std::string，一樣有三個參數，分別為從哪一個串流物件讀、存放的字串、結束字符，其中結束字符一樣可省略
```typescript=
char str1[100];
cin.getline(str1, 100);

string str2;
getline(cin, str2);
```

---

## 連續輸入直到檔案結尾(EOF)

題目如果有寫著"多筆測資，輸入測資到檔案結束"你就知道程式要一直吃輸入直到輸入結束

聽到這樣的敘述，如果你學過while，你可能會想用while解決，那終止條件要怎麼設定呢？

```typescript=
int n;

while (scanf("%d", &n) != EOF) {
  //do something
}

//因為通常EOF的值是-1，所以也可以這樣寫
while (scanf("%d", &n) != -1) {
  //do something
}

//考慮-1取not值就會變成0，所以也可以這樣寫
while (~scanf("%d", &n)) {  //0就是false
  //do something
}

//其實也可以不用這麼麻煩：cin如果讀得到東西就會是true，讀不到就是false
while (cin >> n) {
  //do something
}
```

---

## 不讀完整行

有時候輸入太多，把它全部讀進來會TLE，這時候可以考慮cin.ignore()，他會幫你把整行輸入省略掉，直接從下一行開始讀
```cpp=
int n;
cin >> n;
if (n > 50) cin.ignore();
else {
  int arr[n];
  for (int i = 0; i < n; i++) cin >> arr[i];
}
```
像上面這份code就會把輸入放進arr，只要輸入個數不超過50個

---

## 字串串流(stringstream)

雖然他聽起來很星爆，它實際上也還真的很星爆，假設我今天有一些數字$N_i$，我不知道有幾個，然後每個數字之間以空格隔開，問你$\Sigma N_i$是多少，你可能會想出暴力吃一整行字串再做處理，但實際上有很好用的東西，他叫stringstream，他很星爆
```typescript=
string str = "7122 123 4456 696 87 40";
stringstream ss;
ss << str;
int tmp, sum = 0;
while (ss >> tmp) {
  sum += tmp;
}
cout << sum << '\n';
```
你看到這裡，你還不覺得他很星爆嗎？str用<<塞進我的ss，然後再用>>可以把它一個一個數字拿出來。一言以蔽之，星爆

---

## 位元

###### 為方便起見，這單元會一直用二進位制來表示數字，敬請見諒

這個章節是為了講位元運算而不得不先講的。問題：電腦是怎麼存一個數字的？

相信大家都知道電腦是用2進制儲存所有數字，在此不多贅述。也就是說，對於所有數字(int)，電腦會用4個位元組(byte)來存，也就是用32位元(bit)。但必須注意到為了要存負數，電腦會用2補數(2' compoment)的方式來存，換言之，雖然有32個bit，但只有後31個會被拿來存值，第一位會被拿來標示正負號。

先講什麼是2補數好了，根據維基百科，2補數是一種存有號二進位數的方式。具體來說，正數和0的2補數就是該數字本身。負數的2補數則是將其對應正數按位元取反再加1，其中第一位若是$0$表示其為正數，反之則是負數。

拿8-bit的系統來講好了，假設我現在有一個數字$01111010_2$就表示他的值是$122_{10}(0\times2^0+1\times2^1+0\times2^2+1\times2^3+1\times2^4+1\times2^5+1\times2^6)$，
因為第一位是$0$，表示他是$+122_{10}$

很快的，你會發現他的最大值是$01111111_2$，也就是$127_{10}=2^{8-1}-1$，到這邊都還算好理解，畢竟只是原本的二進位制而已。問題來了：那負數呢？

一個很直觀的方法：我今天如果要存$-122_{10}$，那我就先存$122_{10}$，之後再把他的第一位改成$1$。這個方法看似沒什麼問題，但$0_{10}$要怎麼存？是$00000000_2$還是$10000000_2$呢？$0$的表示法不唯一成了這個存法最大的問題。

另一個很常見的想法：我今天如果要存$-122_{10}$，那我就先存$122_{10}$，之後再將每個位元反轉，也就是把$0$的位元改成$1$，反之亦然。這個存法叫做1補數，問題一樣在於$0_{10}$還是有兩種表示法$00000000_2$跟$11111111_2$，也就是$+0$跟$-0$。

於是就有人改良了1補數，產生了一個制度上相對麻煩很多但卻有更多很好的性質的存法：2補數。他具體的存法是先做1補數，之後再$+1$。

舉例來說，我今天要存$-122_{10}$，那我一樣先存$122_{10}$，之後取他的1補數($10000101_2$)，接下來再$+1$($10000110_2$)。根據剛才的經驗，這樣會不會還是有$+0$和$-0$的問題呢？

答案是不會，~~不信的話你自己試試看~~原因是我們試著做做看$0$的2補數，你會發現他的1補數是$11111111_2$(對所有位元取反)。之後再$+1$，變成$100000000_2$，但我們是用8-bit的系統，所以那個$1$是存不進去的，換言之，存起來會是$00000000_2$，也就完美迴避了$+0$和$-0$的問題呢！

在這個章節的最後再講一下值域好了。你應該會發現用二補數存的數字最大值是$01111111$，也就是$+127$。至於最小值呢？你會想直接拿$+127$取反再$+1$得$10000001_2$，也就是$-127$，並以為這就是最小值。但別忘了，$10000000_2$顯然會比$10000001_2$來的小。換言之最小值其實是$-128$。值域就是$[+127,-128]$，也就是$[2^{8-1}-1,-2^{8-1}]$。

附上維基的表格

![](https://i.imgur.com/yPRT16D.png)

好，講了這麼多，以上就是2補數的內容，看到這裡的你，辛苦了。

---

## 位元運算

大家還記得邏輯運算子嗎？位元運算基本上是一樣的東西，只是他是對數字或位元作。那就讓我們先複習一下邏輯運算子吧！

邏輯運算子有三種，大致上可以分成兩類：一元運算子以及二元運算子。其中一元的邏輯運算子只有一個NOT(!)，二元運算子則是有AND(&&)及OR(||)。

位元運算基本上較常用的也是這些(但長相稍微變得不太一樣)以及一個叫做XOR(^)、一個叫補數(~)的運算子。以下分項介紹：

#### AND運算

先上code
```typescript=
cout << (0 & 0) << '\n';  //print 0
cout << (1 & 0) << '\n';  //print 0
cout << (0 & 1) << '\n';  //print 0
cout << (1 & 1) << '\n';  //print 1
```

這是只做bool之間的運算結果，但問題在於，不只有bool可以進行位元運算，最常用的int也可以做

```typescript=
cout << (205 & 211) << '\n';  //print 193
```
我知道你開始搞不懂為什麼會跑出這種奇怪的結果了。在解釋之前，讓我先確定你知道電腦是怎麼存數字的，如果你不知道，請回去看上個章節。那就讓我們開始解釋為什麼會有這樣的結果吧

205是如何被存在電腦裡的？我們都知道是以二進制，也就是以$11001101_2$(前面空的位元不寫)，同時，211則是$11010011_2$，結果的193則是$11000001_2$，這樣寫你或許看不懂，那我們換個寫法好了
```
   11010011  205
&  11001101  211
------------
   11000001  193
```
有發現什麼嗎？沒錯，如果一個位元在205和211都是1的話，則那個位元在193也會是1。換句話說，&運算是在把兩個數裡所有有1的位元留下，其他全改為0

#### OR運算

一樣先上code
```typescript=
cout << (0 | 0) << '\n';  //print 0
cout << (1 | 0) << '\n';  //print 1
cout << (0 | 1) << '\n';  //print 1
cout << (1 | 1) << '\n';  //print 1
```

一樣，他也有int的運算模式~~不然就不會出現在這個章節了~~

```typescript=
cout << (205 | 211) << '\n';  //print 223
```
印出223的原因基本上是跟前面的理由一樣的，但他是逐個位元做or運算
```
   11010011  205
|  11001101  211
------------
   11011111  223
```

#### XOR運算

這個運算大家平常應該沒用過，所以先上真值表

![](https://i.imgur.com/dJ1KNqZ.png)

其實就是如果a, b不一樣的話就是$true(1)$，否則就是$false(0)$
然後他的運算符是'^'，所以code看起來會是這樣

```typescript=
cout << (205 ＾ 211) << '\n';  //print 30
```
理由基本上是一樣的
```
   11010011  205
^  11001101  211
------------
   00011110   30
```

#### NOT運算

你知道有!這個邏輯運算子，他會把變數的真值改成另一個。但對於一個整數，如果你對他用!的話，他只會變成0或者是1。要用像上面那些用法的話要用補數(~)

#### 補數

補數的運算符是'~'

```typescript=
cout << (~205) << '\n';  //print -206
```
理由基本上一樣，但要注意到，前面說過int會用到32個位元，所以他會反轉全部32個位元，而不是像前面幾種運算子實際上只會處理有值的最大範圍，運作原理大概像下面這樣
```
~  000...11010011  205
------------------
   111...00101100  -206   
```

#### 左/右移運算子

##### 左移運算子 <<

你是不是以為這樣就結束了？想不到這裡還有我~~鎖鏈的康妮~~左右移運算子吧！

一樣先上code~~不然直接講你們也看不懂~~

```typescript=
cout << (205 << 2) << '\n';  //print 820
```
蛤？這東西在幹嘛？我根本沒看懂他在做啥欸...於是我們再次派上老東西
```
   000011010011  205
----------------
   001101001100  820
```
如果你觀察力很好，你或許就會注意到820的位元長相其實就是205整個左移兩格，也就是把205乘上兩次2，得到820。換句話說，<<會把所有位元向左邊移，移幾格則由<<後面的參數決定，原本最後一個位元的後面幾位則是補上0。以剛才的例子來說就是向左移兩格。那下一個問題來了：如果超出最左邊的位元呢？

答案出乎意料地簡單：不要理他，把它丟掉就好了。

換句話說，a << b其實等價於a *= 2^b，差別在於他會比原本的乘法來得快

##### 右移運算子 >>

先上code都快變成老默契了
```typescript=
cout << (205 >> 2) << '\n';  //print 51
```
理由我今天不太想附上，反正和前面那個差不多，大家自己看一下應該就可以搞懂了

值得注意的是，他在把位元向右邊移的時候是直接把最右邊的位元推掉，最左邊的位元補0，所以a >> b也確實等價於a /= 2^b，也會是以無條件捨去的方法來處理小數點後

以上大概就是位元運算的內容，學完了這些你或許會好奇他有什麼用途。~~為了不破下學期課的梗~~這邊先不提，大家可以稍微想一下，其中部分用途也和前面提到的2補數具有的好性質有關喔！

---

## switch 條件判斷

其實這不怎麼重要，但他會讓code的可讀性大大上升，所以我還是寫一下好了

```typescript=
switch (sth) {
  case cond1 :  //case 1
    //do something
  case cond2 :  //case 2
    //do something
  default :  //else
    //do something
}
```

這東西和以下的code基本上是等價的

```typescript=
if (sth == cond1) {
  //do something
}
else if (sth == cond2) {
  //do something
}
else {
  //do something
}
```

簡單來說，就是把一直重複的判斷要用的東西放進switch裡面，然後一一假設可能出現的狀況並對應結果，最後的default則是在沒有進入前面任何一種條件是會進入的條件，可不寫。

---

## 神奇的 for-loop

for迴圈大家一開始的寫法都是
```cpp=
for (int i = 0; i < n; i++) {
  //do something
}
```
但實際上他的用途不僅止於此，首先我們釐清for的括號裡三個敘述分別是什麼
- 第一個敘述，也就是我們常用int i = 0那個地方，他的特性是只會在剛進for時做一次這件事，也就是只做**初始化**
- 第二個敘述i < n是指在什麼**條件**下會進入這個for-loop
- 第三個敘述i++是在每次for-loop裡面的東西**做完之後**才會做的事

那你可以發現，這些東西不見得要好好設定，舉例來說，你還是可以用for寫出無窮迴圈的
```cpp=
for (; ; ) {
  //do something
}
```
方法很簡單，只要不寫任何敘述，他就可以讓你電腦燒掉了喔^_\^
除此之外，for迴圈還有很酷的東西，舉例來說，你可以注意到我在上面第一、三個敘述那邊用的字是"做一次這件事"及"做完之後才會做的事"，沒有限制要做什麼事，換言之，你大可以在那邊搞事
```cpp=
string str;
cin >> str;
for (int i = str.length(); i > 0; cout << str[i]) {
  i--;
}
cout << endl;
```
這份code是可以好好執行起來的，他會把輸入字串倒轉再輸出出來
除此之外，for還有其它用法
```cpp=
string str;
cin >> str;
reverse(str.begin(), str.end());
for (char i : str) cout << i;
cout << endl;
```
這份code可以做到和上面那份一樣的事，中間有一行reverse()是會把一個區間內的東西反過來放回去，但他不是我們今天的重點

讓我們把鏡頭對到for (char i : str)這句，他的意思是指i會是str的現在這格，然後隨著迴圈迴圈(?)，現在的位置會一直往後移動，在str結束時跳出迴圈

不只有字串，陣列之類的當然也有相同的語法
```cpp=
int arr[12];
arr[0] = 0;
for (int i = 1; i < 12; i++) arr[i] = arr[i - 1] + i;
for (int i : arr) cout << i << ' '; //0 1 3 6 10 15 21 28 36 45 55 66 
```
反正大概就是這樣，滿好用的，尤其是在後面一些stl的資結(例如map)支援這種操作的時候

---

## 神奇的 loop

有時候我們如果可以把一些迴圈在他還沒結束時就停掉的話時間上會好很多，舉例來說，如果在用for loop枚舉的時候已經找的目標了，我們其實就可以離開迴圈，那要怎麼實作呢？
```cpp=
int n, x ,arr[n];
for (int i : arr) {
  if (i == x) {
    //do something
    break;
  }
}
```
while loop也有一樣的用法，也是break就好了
那我們現在考慮另一種情境，在某些狀況下，我們覺得在現在的狀況下已經沒有要做的事情了，但在下一次的for loop時我們還有要做事，那這個時候我們很難好好用break來做到，有沒有其他好的語法可以處理呢？
```cpp=
int n, x[n], arr[n];
for (int i = 0; i < n; i++) {
  if (i == arr[i]) {
    x[i] = i;
    continue;
  }
}
```
同樣的，while裡也有一樣的語法可以用喔～

---

## do-while

這東西基本上知道就夠了，要不要會用隨便你

```typescript=
do
  //do something
while (sth);
```

那他也幾乎等價於

```typescript=
//do something
while (sth) {
  //do something
}
```

反正就是先做一次再開始執行while裡面的動作

---

## 初始設定

我們常會需要在一開始時先把某些連續的記憶體(陣列)先設成某個值，之後再把它改掉，如果沒被改掉(覆蓋掉)就表示這格沒再被設定到。

那要怎麼實作呢？

舉例來說，我們今天要把長度為n的arr設成x的話我們可以這樣寫

```cpp=
int n, arr[n], x;
for (int i = 0; i < n; i++) arr[i] = x;
```

今天如果arr是長度為n的長度為n的陣列呢？

```cpp=
int n, arr[n][n], x;
for (int i = 0; i < n; i++) {
  for (int j = 0; j < n; j++) {
    arr[i][j] = x;
  }
}
```

很顯然code的複雜程度上升很快，我們要怎麼調整？

```cpp=
#include <algorithm>
int n, arr[n], x;
fill (arr, arr + n, x);
```

好麻煩喔，而且如果是二維的還要設二維的fill，好煩喔

```cpp=
#include <cstring>
int n, arr[n], x;
memset(arr, x, sizeof(arr));
```

\*問題解決\*

喔但是我發現我這樣寫好像會讓你覺得fill就是一個次級的memset而已，但實際上不是如此，兩個原理不同，我現在不太想解釋，而且我也不太會解釋，所以有興趣了解的可以自己查一下喔～