---
slideOptions:
  theme: league
  transition: 'slide' 
  backgroundTransition: 'fade'
title: 竹中軟研第二次競賽題解
---

<!-- CSDC35thcontestIISlides -->

## 竹中軟研第二次競賽題解
$$
\\\\
$$
出題者：$\frak{solocat}$

----

### [竹中軟研第二次競賽連結](https://csdc.tw/contest/19)
### [竹中軟研第二次競賽簡介](https://hackmd.io/@solocat/CSDC35thcontestII)
### [竹中軟研第二次競賽題解](https://hackmd.io/@solocat/CSDC35thcontestIISlides)

----

## 計分板

![](https://i.imgur.com/wsJespg.png =65%x)

---

## pA 與雪乃有約

- 題目：給你一張$N$個點$m$條邊的無向帶權圖，求從第$1$個點走到第$N$個點的最短路徑長

----

### 名詞解釋：圖

- 圖$(Graph)$：一個由點集$(Vertex)$和邊集$(Edge)$構成的東西
- $$G=(V,E)$$<!-- .element: class="fragment" data-fragment-index="1" -->
- $(v_1, v_2)\in E$ 表示兩點$v_1, v_2\in V$ 有連線<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 名詞解釋：無向圖/有向圖

- 一張無向圖表示所有邊沒有標方向可以任意走，相反的，有向圖只能走標記方向

![](https://i.imgur.com/0v1QZ5X.png =40%x) ![](https://i.imgur.com/uLXdFVW.png =40%x)


----

### 名詞解釋：帶權圖

- 一張帶權圖表示他的所有邊都有一個權重，通常是指距離或價值

![](https://i.imgur.com/1AbJloH.png =60%x)

----

### 名詞解釋：最短路徑

- 一張圖上$u$到$v$的最短路徑只在圖上從$u$走到$v$會經過的最小權重和

![](https://i.imgur.com/YjgmbB4.png =60%x)

----

### 解法

- 題目就是很單純的最短路，你可以自己隨便google一下就有了
$\quad$

#### 常見的幾種最短路徑演算法

- Floyd-Warshall
- Bellman-Ford
- SPFA
- Dijkstra
- A*

---

## pB 照妖鏡前面的階梯

- 題目：三階費式數列的第$N$項，$1\leq N\leq 10^9$
$$
T_n = T_{n - 1} + T_{n - 2} + T_{n - 3}
$$

----

### 複雜度估計

- 意思就是指你的演算法會隨著測資規模上升的多快，我們常用$\mathcal O$來估計，讀作$\text{Big-O}$，但注意其不等於時/空間複雜度
- $\mathcal O(N)\to$時/空間消耗成長規模與資料規模的成長關係規模近似線性
- $\mathcal O(N^2)\to$時/空間消耗成長與資料規模成長之比例近似於平方關係
- $\mathcal O(2^N)\to$時/空間消耗與資料規模約以指數關係成長(很糟的複雜度的意思)

----

### 遞迴？

- 每次找$T_n$時，會詢問$T_{n - 1}, T_{n - 2}. T_{n - 3}$，尋找一個值可以被視為找比他小$1$的三個值($1,2,3$只差一點點不用在意)
- $n$要減去$n$次$1$才會變$0$(演算法結束)，所以會做$N$次<!-- .element: class="fragment" data-fragment-index="1" -->
- 每次找三個且要找$N$次<!-- .element: class="fragment" data-fragment-index="2" -->$\to \mathcal O(3^N)$<!-- .element: class="fragment" data-fragment-index="2" -->
- 顯然慢炸<!-- .element: class="fragment" data-fragment-index="3" -->


----

### 優化過後的遞迴？

- 注意到不管是從$T_{n+1}, T_{n+2}, T_{n+3}$往前找的$T_n$都是同一個值，我們可以做過一次$T_n$就把他的值記錄下來，這樣就不用一直重複算
- 每個數字都要算一次且有$N$個數字要算<!-- .element: class="fragment" data-fragment-index="1" -->$\to \mathcal O(N)$<!-- .element: class="fragment" data-fragment-index="1" -->
- 通常這複雜度還算可以，但這題的$N\leq 10^9$，所以***原則上*** 不會過<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 快速冪

- 雖然很突然，但我想問你要怎麼算$a^n$

----

### Naive

```cpp=
int ans = 1;
for (int i = 0; i < n; i++) {
  ans *= a;
}
```
- $\mathcal O(N)$<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 二進位制

- 看著$a^{16}$，你會發現它可以被表示成$a^{10000_2}$
- 看著$a^{16}$，你會發現它就是<!-- .element: class="fragment" data-fragment-index="1" -->$(a^8)^2=((a^4)^2)^2=(((a^2)^2)^2)^2$<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 聽不懂？

```cpp=
int a, n, ans = 1;
for (; n; n >>= 1, a *= a)
  if (n & 1)
    ans *= a;
```

----

### 思考

\begin{equation}
  a^n=
  \begin{cases}
    a(a^\frac{n - 1}{2})^{2},&\text{if $n$ is odd}\\
    (a^\frac{n}{2})^{2},&\text{if $n$ is even}
  \end{cases}
\end{equation}

----

### 複雜度？

- $\mathcal O(\log_2n)$

----

### 矩陣乘法

$$
(AB)_{ij}=\sum_{r=1}^n A_{ir}B_{rj}=A_{i1}B_{1j}+A_{i2}B_{2j}+\cdots+A_{in}B_{nj}
$$

----

### 矩陣乘法

$$
\begin{bmatrix} a_1&b_1\\c_1&d_1 \end{bmatrix}
\cdot
\begin{bmatrix} a_2&b_2\\c_2&d_2\end{bmatrix}=
\begin{bmatrix} a_1a_2+b_1c_2&a_1b_2+b_1d_2\\
c_1a_2+d_1c_2&c_1b_2+d_1d_2 \end{bmatrix}
$$

----

### 矩陣乘法

$$
\begin{bmatrix} 1&0&2\\-1&3&1 \end{bmatrix}\cdot
\begin{bmatrix} 3&1\\2&1\\1&0 \end{bmatrix}\\=
\begin{bmatrix} 1[3&1]+0[2&1]+2[1&0]\\-1[3&1]+3[2&1]+1[1&0] \end{bmatrix}\\=
\begin{bmatrix} [3&1]+[0&0]+[2&0]\\ [-3&-1]+[6&3]+[1&0] \end{bmatrix}=
\begin{bmatrix} 5&1\\4&2 \end{bmatrix}
$$


----

### 觀察原式

$$
T_n=T_{n-1}+T_{n-2}+T_{n-3}\\
\begin{bmatrix} T_n\\T_{n-1}\\T_{n-2} \end{bmatrix}=
\begin{bmatrix} 1&1&1\\1&0&0\\0&1&0 \end{bmatrix}\cdot
\begin{bmatrix} T_{n-1}\\T_{n-2}\\T_{n-3} \end{bmatrix}
$$

----

$$
\because\begin{bmatrix} T_n\\T_{n-1}\\T_{n-2} \end{bmatrix}=
\begin{bmatrix} 1&1&1\\1&0&0\\0&1&0 \end{bmatrix}\cdot
\begin{bmatrix} T_{n-1}\\T_{n-2}\\T_{n-3} \end{bmatrix}\\又
\begin{bmatrix} T_{n-1}\\T_{n-2}\\T_{n-3} \end{bmatrix}=
\begin{bmatrix} 1&1&1\\1&0&0\\0&1&0 \end{bmatrix}\cdot
\begin{bmatrix} T_{n-2}\\T_{n-3}\\T_{n-4} \end{bmatrix}\\\therefore
\begin{bmatrix} T_n\\T_{n-1}\\T_{n-2} \end{bmatrix}=
\begin{bmatrix} 1&1&1\\1&0&0\\0&1&0 \end{bmatrix}^{n-3}\cdot
\begin{bmatrix} T_{3}\\T_{2}\\T_{1} \end{bmatrix}
$$

----

### 搭配快速冪

$$
\begin{bmatrix} T_n\\T_{n-1}\\T_{n-2} \end{bmatrix}=
\begin{bmatrix} 1&1&1\\1&0&0\\0&1&0 \end{bmatrix}^{n-3}\cdot
\begin{bmatrix} T_{3}\\T_{2}\\T_{1} \end{bmatrix}
$$

- 可在$\log$級別時間內求出中間那個矩陣的$n-3$次方，再乘上已知的前三項就可以在$\mathcal O(\log N)$的時間內`AC`這題<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 用途？

- 快速冪？
  - 很常用到就是了<!-- .element: class="fragment" data-fragment-index="1" -->
  - 用途很多，日常生活中都有可能出現(你的數學考卷之類的)<!-- .element: class="fragment" data-fragment-index="2" -->
- 矩陣快速冪？<!-- .element: class="fragment" data-fragment-index="3" -->
  - 你可能會覺得用不到<!-- .element: class="fragment" data-fragment-index="4" -->
  - 還是用得到的<!-- .element: class="fragment" data-fragment-index="5" -->

----

### TRML個人賽-2020 第二回

- $\text{I-7.}$ 若$\begin{bmatrix}1&3\\0&2\end{bmatrix}^n=\begin{bmatrix}a_n&b_n\\c_n&d_n\end{bmatrix}$，其中$n$為正整數，則$\frac{b_{18}}{b_9}$之值為＿＿。
- 筆者在當時沒想到怎麼推遞迴一般式，果斷選擇矩陣快速冪<!-- .element: class="fragment" data-fragment-index="1" -->
- AC<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 假解

- by. joey123230、潘勁諺
- 考慮$\mathcal O(N)$的作法<!-- .element: class="fragment" data-fragment-index="1" -->
- 注意到$N<10^8$時都可以在1秒內跑完<!-- .element: class="fragment" data-fragment-index="2" -->
- 那我們就對測資分段處理，先做出每個長度為$10^8$的區間左界的值，再判斷他是在哪個區間內去算出他的值<!-- .element: class="fragment" data-fragment-index="3" -->
- 複雜度雖然還是$\mathcal O(N)$，但因為你的$N$變小了，最大只會到$10^8$，所以會過(這個說法超不嚴謹的請不要罵我QwQ)<!-- .element: class="fragment" data-fragment-index="4" -->
- 早知道我就把$N$開大一點，改成$N\leq 10^{12}$就不會有問題了QwQ<!-- .element: class="fragment" data-fragment-index="5" -->

---

## pC 二次函數與他們的交點

- 題目：給一堆二次函數求交點個數

----

### 結論

- 哈哈其實是梗題啦
- 題目靈感：NPSC2020決賽pF

----

### 二次函數圖形

- $$\Gamma _i:y=a_i(x-b_i)^2$$
- $$\quad\ \ \Gamma _i:y=a_i(x-b_i)^2+0$$<!-- .element: class="fragment" data-fragment-index="1" -->
- 所有圖形的極值都發生在$x=b_i,y=0$時<!-- .element: class="fragment" data-fragment-index="2" -->

----

### $b_i$的思考

- $$b_i = \frac{\text{B[i]}}{\prod_{j = 1}^i \text{B[j]}}$$
- $$b_i = \frac{1}{\prod_{j = 1}^{i - 1} \text{B[j]}}$$<!-- .element: class="fragment" data-fragment-index="1" -->
- 根據給定的亂七八糟生成程式碼，且$\because\forall a_i$相異，$\therefore \forall \text{B[i]}$都不為$1$或<!-- .element: class="fragment" data-fragment-index="2" -->$0$<!-- .element: class="fragment" data-fragment-index="2" -->
- $\therefore$所有$b_i$都相異<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 基本數學

- 任意兩個開口大小不一樣，極值$x$座標相異但都發生在$\text{x}$軸上的二次函數圖形圖形有幾個交點？
  > 阿你是不會自己畫圖？ <!-- .element: class="fragment" data-fragment-index="1" -->
- 考慮正負<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 這樣就結束了嗎？

- 原本這題只有這樣，但...
- 出題者一開始沒有想過有沒有可能發生三個函數共點的狀況，禮拜五才得知這點...<!-- .element: class="fragment" data-fragment-index="1" -->
- 試著證明不可能發生共點的狀況！<!-- .element: class="fragment" data-fragment-index="2" -->
- 抱歉我數學太差不會證明他不會三函數共點<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 那他有多高的機率共點？

- 微乎其微
- ~~考慮到開口大小都是整數，函數極值集中發生在$\text{x}$座標接近0，*感覺* 它就不會有三函數共點的發生~~<!-- .element: class="fragment" data-fragment-index="1" -->
- 我有把測資經過一些縮放之後都丟進GGB，看起來是不會共點的...<!-- .element: class="fragment" data-fragment-index="2" -->
- 所以最後我只能加一行跟你講說保證不會發生三個函數共交點的狀況<!-- .element: class="fragment" data-fragment-index="3" -->

---

## pD 眩しさだけは、忘れなかった。

- 題目：$N$個物品環狀排列，只能和左右兩側的人交換物品，求把所有人的物品數量換成平均值的最少交換次數

----

### 題目來源

- 去年的數學分組考考卷，感謝明弘><
- [洛谷P4016](https://www.luogu.com.cn/problem/P4016)<!-- .element: class="fragment" data-fragment-index="1" -->
- 為了讓寫網路流作法的人不要被卡掉，這題的測資範圍和上面那題一樣<!-- .element: class="fragment" data-fragment-index="2" -->
- 這題被標在"網路流24題"裡面，有興趣的人可以考慮用網路流做做看<!-- .element: class="fragment" data-fragment-index="3" -->
- 好像只有一個[離世界最近的學校](http://www.nehs.hc.edu.tw/)科學班高一[某不具名資訊學科能力競賽全國賽二等獎電神](https://codeforces.com/profile/PixelCat)用最小費用最大流過<!-- .element: class="fragment" data-fragment-index="4" -->

----

### 好好算數學

- 會先講我第一次看到這題的做法+網路上看到的比較簡單(?)的理解<!-- .element: class="fragment" data-fragment-index="1" -->
- 其實大同小異<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 好好算數學

- 可以把所有數都當成他自己與平均值$\mu$的差
- 假設第$i$個人有$a_i-\mu$根<!-- .element: class="fragment" data-fragment-index="1" -->
- 注意到每個人在與他左右邊的人傳完之後他的數量不再改變<!-- .element: class="fragment" data-fragment-index="2" -->
- 假設第$1$個人傳給第$N$個人$k$根，則第$2$個人應給他$\mu+k-a_1$根<!-- .element: class="fragment" data-fragment-index="3" -->
- $\cdots$<!-- .element: class="fragment" data-fragment-index="4" -->

----

### 好好算數學

- 第$2$個人給第$1$個人的花費是$|\mu+k-a_1|$
- 第$3$個人給第$2$個人的花費是<!-- .element: class="fragment" data-fragment-index="1" -->$|2\mu+k-a_1-a_2|$<!-- .element: class="fragment" data-fragment-index="1" -->
- $\cdots$<!-- .element: class="fragment" data-fragment-index="2" -->
- 注意到最後的花費會是一堆絕對值的和<!-- .element: class="fragment" data-fragment-index="3" -->
- $$\sum_{i=1}^N|k-\sum_{j=1}^i(\mu-a_j)|$$<!-- .element: class="fragment" data-fragment-index="4" -->

----

### 好好算數學

- $$\sum_{i=1}^N|k-\sum_{j=1}^i(\mu-a_j)|$$
- 絕對值和最小值發生在$k=$ 中位數時<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 好好算數學-2

- 假設第$i(1\leq i\leq N)$人一開始有$a_i$枝冰棒，總共有$\mu N$枝冰棒<!-- .element: class="fragment" data-fragment-index="1" -->
- 注意到每個人在與他左右邊的人傳完之後他的數量不再改變<!-- .element: class="fragment" data-fragment-index="2" -->
- 假設第$i$個人給第$i-1$個人$x_i$枝，特別的，我們假設第$0$個人即為第$N$個人，則不難發現<!-- .element: class="fragment" data-fragment-index="3" -->
- $$a_i-x_i+x_{i+1}=\mu$$<!-- .element: class="fragment" data-fragment-index="4" -->
- $$x_{i+1}=x_i+\mu-a_i$$<!-- .element: class="fragment" data-fragment-index="5" -->

----

### 好好算數學-2

- \begin{cases}
  x_1=x_n+\mu-a_n\\
  x_2=x_1+\mu-a_1\\
  x_3=x_2+\mu-a_2\\
  \cdots\\
  x_n=x_{n-1}+\mu-a_{n-1}
  \end{cases}<!-- .element: class="fragment" data-fragment-index="1" -->
- 好多未知數怎麼解<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 好好算數學-2

- ~~亂帶看看~~
- \begin{split}
  x_3&=x_2&+\mu-a_2\\
     &=(x_1+\mu-a_1)&+\mu-a_2\\
  \end{split}<!-- .element: class="fragment" data-fragment-index="1" -->
- $$x_3=x_1+2\mu-a_1-a_2$$<!-- .element: class="fragment" data-fragment-index="2" -->
- 變數不夠用了<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 好好算數學-2

- 假設新的變數<!-- .element: class="fragment" data-fragment-index="1" -->$S_i=(\sum_{j=1}^{i-1} a_j) -i \mu$<!-- .element: class="fragment" data-fragment-index="1" -->
- 把$x$換成<!-- .element: class="fragment" data-fragment-index="2" -->$S$<!-- .element: class="fragment" data-fragment-index="2" -->
- \begin{split}
  &S_2=a_1+a_2&-2\mu\\
  &S_3=a_1+a_2+a_3&-3\mu
  \end{split}<!-- .element: class="fragment" data-fragment-index="3" -->
- $$S_3=S_2-\mu+a_3$$<!-- .element: class="fragment" data-fragment-index="4" -->
- $\cdots$<!-- .element: class="fragment" data-fragment-index="5" -->
- $$S_i=S_{i-1}-\mu+a_i$$<!-- .element: class="fragment" data-fragment-index="6" -->

----

### 好好算數學-2

- 把$x$帶回來看看好了...<!-- .element: class="fragment" data-fragment-index="1" -->
- \begin{split}
  &x_2=x_1-S_1\\
  &x_3=x_1-S_2\\
  &x_4=x_1-S_3\\
  &\cdots\\
  &x_n=x_1-S_{n-1}
  \end{split}<!-- .element: class="fragment" data-fragment-index="2" -->
- 還記得答案應該是求<!-- .element: class="fragment" data-fragment-index="3" -->$\min(\sum_{i=1}^n |x_i|)$<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 好好算數學-2

- \begin{split}
  {\sum_{i=1}^n |x_i|}&=|x_1|&+|x_2|&+\cdots+|x_n|\\
  &=|x_1-0|&+|x_1-S_1|&+\cdots+|x_1-S_{n-1}|
  \end{split}<!-- .element: class="fragment" data-fragment-index="1" -->
- 絕對值和最小發生在中位數<!-- .element: class="fragment" data-fragment-index="2" -->

---

## pE 我喜歡矩形啦><

- 題目：多次給你一個四邊形的四個頂點，問你是不是矩形$+$算四邊形的面積

----

### 向量基本運算

- 向量加減法
- 向量乘法：純量積、點(內)積$(\cdot)$、叉(外)積$(\times)$

----

### 向量加法

- 假設現在有兩個向量，分別為$\vec{v_1}=(x_1,y_1), \vec{v_2}=(x_2,y_2)$，則
- $$\vec{v_1}+\vec{v_2}=(x_1+x_2, y_1+y_2)$$<!-- .element: class="fragment" data-fragment-index="1" -->

![](https://i.imgur.com/RwAslid.png =30%x)<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 向量減法？

- 就是反過來的加法<!-- .element: class="fragment" data-fragment-index="1" -->
- 可視為加上負的向量<!-- .element: class="fragment" data-fragment-index="2" -->

![](https://i.imgur.com/U6bFpOE.png =30%x)<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 純量乘法

- 純量積：假設有一個向量$\vec{v}=(x,y)$和一個實數$a$，則
- $$a\vec{v}=(ax,ay)$$<!-- .element: class="fragment" data-fragment-index="1" -->

![](https://i.imgur.com/Ul9emgK.png =30%x)<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 內積

- $\exists$兩個非$\vec{0}$(非零向量) $\vec{v_1}=(x_1. y_1), \vec{v_2}=(x_2,y_2)$，夾角為$\theta$，則
- $$\vec{v_1}\cdot\vec{v_2}=|\vec{v_1}||\vec{v_2}|\cos\theta\\=(x_1x_2+y_1y_2)$$<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 內積

- 性質：
  - 內積出來會是純量而非向量
  - 兩相垂直的向量內積為$0$
- 內積當然可以拓展到更高的維度，對於兩個$n$維向量$\vec{a}=(a_1,a_2,\cdots,a_n),\vec{b}=(b_1,b_2,\cdots,b_n)$，則<!-- .element: class="fragment" data-fragment-index="1" -->
- $$\vec{a}\cdot\vec{b}=\sum_{i=1}^n a_ib_i=a_1b_1+a_2b_2+\cdots+a_nb_n$$<!-- .element: class="fragment" data-fragment-index="2" -->
- 但我們這題只在二維，暫不討論更高維度<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 外積

- $\exists$兩個非$\vec{0}$(非零向量) $\vec{v_1}=(x_1, y_1,0), \vec{v_2}=(x_2,y_2,0)$，夾角為$\theta$，$\hat{n}$為垂直$\vec{v_1},\vec{v_2}$的單位向量$(0,0,1)$，則
- $$\vec{v_1}\times\vec{v_2}=|\vec{v_1}||\vec{v_2}|\sin\theta\ \hat{n}\\=(0,0,x_1y_2-y_1x_2)$$<!-- .element: class="fragment" data-fragment-index="1" -->

![](https://i.imgur.com/wGiiA2A.png =20%x)<!-- .element: class="fragment" data-fragment-index="2" -->


----

### 外積

- 性質：
  - 外積出一個與原本兩個向量垂直的向量，長度為原本兩個向量張的平行四邊形面積
  - 兩相平行向量外積為0

![](https://i.imgur.com/69ZHArF.png =40%x)<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 回到題目

- 把題目拆解成幾個部分
  1. 判斷是否是矩形<!-- .element: class="fragment" data-fragment-index="1" -->
  2. 要對不是矩形的四邊形求面積<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 矩形性質

- 鄰邊相互垂直<!-- .element: class="fragment" data-fragment-index="1" -->
  - 內積判斷<!-- .element: class="fragment" data-fragment-index="1" -->
- 一個角是直角的平行四邊形<!-- .element: class="fragment" data-fragment-index="2" -->
  - 平行可用外積判斷，直角可用內積判斷<!-- .element: class="fragment" data-fragment-index="2" -->
- 對角線相等的平行四邊形<!-- .element: class="fragment" data-fragment-index="3" -->
  - 平行可用外積判斷，等長可用不開根號的畢氏定理兩次求出<!-- .element: class="fragment" data-fragment-index="3" -->
- 其他<!-- .element: class="fragment" data-fragment-index="4" -->$\cdots$<!-- .element: class="fragment" data-fragment-index="4" -->

----

### 有向面積

- 面積是有方向的

- $$\vec{u}\times\vec{v}=|\vec{u}||\vec{v}|\sin(\theta)\ \hat{n}\\\neq\vec{v}\times\vec{u}=|\vec{u}||\vec{v}|\sin (-\theta)\ \hat{n}\\=-\vec{u}\times\vec{v}$$<!-- .element: class="fragment" data-fragment-index="1" -->

![](https://i.imgur.com/YsSHv31.png =32%x)<!-- .element: class="fragment" data-fragment-index="2" --> ![](https://i.imgur.com/gXlStbx.png =32%x)<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 求多邊形面積

![](https://i.imgur.com/k8NIlAz.png =90%x)

----

### 多邊形面積

1. 任意在平面上選一點$O$
2. 將所有點與$O$點連線<!-- .element: class="fragment" data-fragment-index="1" -->
3. 相鄰兩點將與$O$點形成三角形<!-- .element: class="fragment" data-fragment-index="2" -->
4. 依逆時針(或順時針)依序加總各三角形有向面積即爲該多邊形之有向面積<!-- .element: class="fragment" data-fragment-index="3" -->
- 方便來說，我們常選原點當作<!-- .element: class="fragment" data-fragment-index="4" -->$O$<!-- .element: class="fragment" data-fragment-index="4" -->

----

### 多邊形面積

- 對於一個$N$個點的多邊形，假設點編號依序為$P_0,P_1,P_2,\cdots,P_{N-1},P_N=P_0$，則面積
- $$\frac{1}{2} \sum_{i=0}^{N-1} \vec{P_i}\times\vec{P_{i+1}}$$<!-- .element: class="fragment" data-fragment-index="1" -->

---

## pF 口是心非的雞塊同學

- 題目：帶權矩陣左上走到右下兩遍的最大收益和，每個權值只能拿一次

----

### 中國題目有夠噁心的

- NOIP2000提高組 方格取數<!-- .element: class="fragment" data-fragment-index="1" -->
- [洛谷P1004](https://www.luogu.com.cn/problem/P1004)<!-- .element: class="fragment" data-fragment-index="2" -->
- 我自己一開始也想很久<!-- .element: class="fragment" data-fragment-index="3" -->
- 但也可能是我比較笨的緣故QwQ<!-- .element: class="fragment" data-fragment-index="4" -->

----

### 回想比較簡單的題目

- 帶權矩陣左上走到右下的最大收益，每次只能往右邊或下面走
- 很裸的dp<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 簡單版本

- 考慮二維，`dp[i][j]`存走到$(i,j)$時的最大收益
- dp轉移式：<!-- .element: class="fragment" data-fragment-index="1" -->
- $$dp[i][j]=\max(dp[i-1][j],dp[i][j-1])+a[i][j]$$<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 困難？

- 發現到我們不能用"走兩次簡單版本的作法"，這樣可能拿不到最大收益
- 為什麼？<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 困難？

- 注意到第一次走過的格子值就會被拿完
- 兩次的走法取值會互相影響，第一次拿最多的可能導致第二次會拿太少，以至於最後的和不是最大收益！<!-- .element: class="fragment" data-fragment-index="1" -->
- 那就讓兩次在走的時候會互相影響！<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 解決？

- 注意到我們只要知道當前走了幾步和在一個軸上走了多遠就可以知道當前在另一軸上走了多遠
- 考慮一次兩個人同時走，維護三個維度`dp[i][j][k]`存當前走了`i`步時，兩個人的$\text{x}$座標分別是`j,k`時的最大收益和<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 直接上code比較快

```cpp=
#include <iostream>
#include <cmath>
using namespace std;
#define int long long

int n, dp[30][15][15], mp[15][15];

signed main(){
  cin >> n;
  for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++)
    cin >> mp[i][j];

  dp[2][1][1] = mp[1][1];
  for (int i = 3; i <= 2 * n; i++) {
    int c = min(i, n + 1);
    int s = i > n ? (i - n) : 1;
    for (int j = s; j < c; j++) {
      for(int k = s; k < c; k++) {
        int x1 = j      , x2 = k,
            y1 = (i - j), y2 = (i - k);
        bool b = (x1 == x2 && y1 == y2);
        int tmp = max(max(dp[i - 1][x1 - 1][x2 - 1], dp[i - 1][x1][x2]),
                      max(dp[i - 1][x1 - 1][x2], dp[i - 1][x1][x2 - 1]));

        dp[i][x1][x2] = max(dp[i][x1][x2], tmp + mp[x1][y1] + (b ? 0 : mp[x2][y2]));
      }
    }
  }
  cout << dp[2 * n][n][n] << '\n';
}
```

---

## pG 竹中好臭

- 題目：給一個點集和一條線，問是否超過$\frac{5}{8}$的點在線的同側

----

### 半平面交

- 這題和這個無關，但這個好像很酷，有興趣的可以去查查

----

### 半平面

![](https://i.imgur.com/iY7GjHo.png =80%x)

----

### 整場比賽最水的一題

- 把點帶進去看是否有**至少**$\frac{5}{8}$的點在$(0,0)$的異側就完事了<!-- .element: class="fragment" data-fragment-index="1" -->

---

## pH 區間加值，區間查詢！

- 題目：對一個整數序列$Q$次加值，問序列操作完之後某一段的長相

----

### 大家好像很喜歡這題

- 整場比賽首殺竟然在這題我其實有點訝異
- 好像也有滿多人砸$\mathcal O(N)$加值的做法<!-- .element: class="fragment" data-fragment-index="1" -->
- 全部給你`TLE`下去OwO<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 前綴和

- `[0, 1, 2, 3, 4, 5, 6]`，前綴和下去
- `[0, 1, 3, 6,10,15,21]`<!-- .element: class="fragment" data-fragment-index="1" -->
- $\mathcal O(N)$預處理後可以$\mathcal O(1)$知道某個連續區間的和<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 優點？

- 原本的`arr[]={3, 1, 2, 4, 6, 5}`
- `prefixsum[]={0, 3, 4, 6, 10, 16, 21}`
- 問陣列的前第3項的和?<!-- .element: class="fragment" data-fragment-index="1" -->
  - prefixsum[3]-prefixsum[0]<!-- .element: class="fragment" data-fragment-index="2" -->
- 第2項到第6項？<!-- .element: class="fragment" data-fragment-index="3" -->
  - prefixsum[6]-prefixsum[2]<!-- .element: class="fragment" data-fragment-index="4" -->

----

### stl大法好

```cpp=
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> arr = {3, 1, 2, 4, 6, 5};
  vector<int> prefixsum = {0};
  partial_sum(arr.begin(), arr.end(), back_inserter(prefixsum));
  for (int i = 0; i < prefixsum.size(); i++) 
    cout << prefixsum[i] << " \n"[i == prefixsum.size() - 1];
}
```

- `0 3 4 6 10 16 21`<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 差分序列

- 給你一個序列多次加值，最後多次問你序列某段的長相
- 和這題題目是一樣的

----

### 差分序列在幹嘛

1. 我們有`arr[]`，以`1-based index`，令`arr[0]=0`
2. 我們用`arr[]`蓋出一個`d[]`，其中<!-- .element: class="fragment" data-fragment-index="1" -->`d[i]=arr[i]-arr[i-1]`<!-- .element: class="fragment" data-fragment-index="1" -->
$\quad$
- 如果你今天拿到`d[]`，你能還原出`arr[]`嗎？<!-- .element: class="fragment" data-fragment-index="2" -->
- 可以<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 怎麼做？

- 考慮前綴和，假設前綴和陣列叫做`p[]`
- \begin{split}
  p[i]=&\sum_{j=1}^i d[j]=(arr[1]-arr[0])+(arr[2]-arr[1])\\&+\cdots+(arr[i]-arr[i-1])\\=&arr[i]-arr[0]=arr[i]
  \end{split}<!-- .element: class="fragment" data-fragment-index="1" -->
- 所以差分序列可以在$\mathcal O(N)$的時間內變回原序列<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 我們需要更快的加值！

- 思考：有沒有辦法讓我們可以更快的對某段序列加值？
- 可以！<!-- .element: class="fragment" data-fragment-index="1" -->
- 藉由定義，我們知道差分序列某一項的值就是他和他前一項在原序列的差<!-- .element: class="fragment" data-fragment-index="2" -->
- 如果我們在差分序列`l`處讓他"多差了`h`"會發生什麼事？<!-- .element: class="fragment" data-fragment-index="3" -->
- 把序列用前綴和技巧還原後，`l`及其之後的所有元素在前綴和序列都會多`h`！<!-- .element: class="fragment" data-fragment-index="4" -->

----

### 事情變得簡單

- 那如果我在差分序列`l`處讓他"多差了`h`"，`r`處"少差`h`"呢？
- `l`之後的所有元素多了`h`，但`r`之後的所有元素又少了`h`！<!-- .element: class="fragment" data-fragment-index="1" -->
- 也就是說我們成功做到$\mathcal O(1)$的區間加值了！<!-- .element: class="fragment" data-fragment-index="2" -->
- $Q$次加值，每次加值都是$\mathcal O(1)$，預處理成差分序列$\mathcal O(N)$，前綴和還原成原本的序列也是$\mathcal O(N)$，整體複雜度就是$\mathcal O(N+Q)$！<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 為什麼可以這樣做？

- 很大一個原因是這題只在所有加值結束之後詢問整個序列的某一段的長相<!-- .element: class="fragment" data-fragment-index="1" -->
- 如果是邊加值邊問的話你可能需要用一個很噁心的資料結構維護<!-- .element: class="fragment" data-fragment-index="2" -->
- 詳情可以看上次社內賽的題解，再稍微修改一點就行了<!-- .element: class="fragment" data-fragment-index="3" -->

---

## pI 第29日 「學長，你有想去的地方嗎？」

- 題目：
- $$C^N_M \mod p$$
- 其中$1\leq N, M, p\leq 10^5$，$p$為質數

----

### 盧卡斯定理

- 你$\text{google}$一下就有了
- $$C^n_m\bmod p = (C^{\lfloor\frac{n}{p}\rfloor}_{\lfloor\frac{m}{p}\rfloor})\times (C^{n\bmod p}_{m\bmod p})\bmod p$$<!-- .element: class="fragment" data-fragment-index="1" -->
- 其中$p$是質數，$\lfloor X\rfloor$指$X$向下取整，因為組合不見得要寫$C$，所以可以寫成<!-- .element: class="fragment" data-fragment-index="2" -->
- $${n\choose m}\bmod p={\lfloor\frac{n}{p}\rfloor\choose\lfloor\frac{m}{p}\rfloor}{n\bmod p\choose m\bmod p}\bmod p$$<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 證明(抄 OI Wikiㄉ)

- 好像會用到一點高等數學工具(?
- 考慮${p\choose n}\bmod p=\frac{p!}{n!(p-n)!}\bmod p$，注意到$p!\equiv0(\bmod p)$，$\therefore \frac{p!}{n!(p-n)!}\bmod p$ 除了在$n=0\vee n=p$ 時都有值<!-- .element: class="fragment" data-fragment-index="1" -->$1$<!-- .element: class="fragment" data-fragment-index="1" -->
- $${p\choose n}\bmod p=[n=0\vee n=p]$$<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 證明

- 二項式定理
- \begin{equation}
  \begin{split}
  (a+b)^p 
  &=\sum_{n=0}^p {p \choose n}a^n b^{p-n}\\
  &\equiv \sum_{n=0}^p [n=0\vee n=p]a^n b^{p-n}\\
  &\equiv a^p+b^p (\bmod p)
  \end{split}
  \end{equation}<!-- .element: class="fragment" data-fragment-index="1" -->
- 注意我們至今沒有用過費馬小定理，因此至此的所有推導亦可適用於多項式上而非僅止於整數域<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 證明

- 考慮一個多項式函數$f(x)=(ax^n+bx^m)^p\bmod p$的值
- \begin{split}
  (ax^n+bx^m)^p
  &\equiv a^p x^{pn} + b^p x^{pm}\\
  &\equiv ax^{pn} + bx^{pm}\\
  &\equiv f(x^p) (\bmod p)\\
  \end{split}
  
<!-- ---- -->

----


### 證明

- 注意到${n\choose m}$即是利用二項式定理展開$(1+x)^n\bmod p$後，$x^m$項的係數，$\therefore$
- \begin{split}
  (1+x)^n
  &\equiv (1+x)^{p\lfloor\frac{n}{p}\rfloor}(1+x)^{n\bmod p}\\
  &\equiv (1+x^p)^{\lfloor\frac{n}{p}\rfloor}(1+x)^{n\bmod p}
  \end{split}
- 考慮上面那行的那個鬼東西，可以注意到根據前面的小結，前半部分只在$kp, k\in\mathbb Z$時有值，而後半部的值最大就是<!-- .element: class="fragment" data-fragment-index="1" -->$p-1$<!-- .element: class="fragment" data-fragment-index="1" -->
- 考慮卷積<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 證明

- 接續上頁，我們發現他的卷積對於每一次項(最多)只會取一次值，而根據上頁的小結，我們發現前半部分只能拿$p$的倍數項，後半部就拿剩的<!-- .element: class="fragment" data-fragment-index="1" -->
- 得到關係式<!-- .element: class="fragment" data-fragment-index="2" -->
- $${n\choose m}\bmod p={\lfloor\frac{n}{p}\rfloor\choose\lfloor\frac{m}{p}\rfloor}{n\bmod p\choose m\bmod p}\bmod p$$<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 我有看到其他證明

- 你們會想聽生成函數的證明嗎？

----

### 我沒做啦哈哈，自己查維基就有了

----

### 怎麼算組合數

- $${n\choose m}= \frac{n!}{m!(n-m)!}$$
- 怎麼求？<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 注意到我們是在模數下做事

- 求出模逆元
- 我可以不要講這段嗎？感覺好累喔<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 假設我們求出模逆元了...

- 你有蓋好階乘的表，蓋好$1,2,\cdots ,p-1,p$的模逆元，那就好好算吧
- \begin{split}
  {n\choose m}
  &\equiv \frac{n!}{m!(n-m)!}\\
  &\equiv n!\times(m!)^{-1}\times ((n-m)!)^{-1}\\
  &\equiv n!\times inv(m!)\times inv((n-m)!) (\bmod p)
  \end{split}<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 難得的附個code告訴你這題不難寫...


```cpp=
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 100005;

int t, n, m, p, i, jc[N], ijc[N];// 階乘與他的模逆元
inline void pre() {
  jc[0] = jc[1] = ijc[0] = ijc[1] = 1;
  for (i = 2; i <= p; i++) {
    jc[i] = jc[i - 1] * i % p;
    ijc[i] = p - (p / i) * ijc[p % i] % p;
  }
  for (i = 2; i <= p; i++) {
    ijc[i] = ijc[i - 1] * ijc[i] % p; 
  }
}

inline int lucas(int OAO, int QAQ){
  if (OAO < QAQ) return 0;
  if (OAO < p) return jc[OAO] * ijc[QAQ] % p * ijc[OAO - QAQ] % p;
  return lucas(OAO / p, QAQ / p) * lucas(OAO % p, QAQ % p) %p;
}

signed main() {
  cin >> t;
  while (t--) {
    cin >> n >> m >> p;
    pre();
    cout << lucas(n, m) << endl;  //C^n_m%p
  }
}
```

----

- 有一個[離世界最近的學校](http://www.nehs.hc.edu.tw/)科學班高一[某不具名資訊學科能力競賽全國賽二等獎電神](https://codeforces.com/profile/PixelCat)用了輸入輸出優化+pragma下去之後沒用Lucas也過了

---

## (原)pJ 前情侶的日常快照 「這麼說起來妳的數學好像很好」

- 題目：$Q$次詢問小於$3\times 10^7$的某段質數連續$\oplus$值

----

### 曾經的題目...

- 我也不知道為什麼，但我在修正題目之後他就爛掉了，所以就把這題換掉了

----

### 線性篩

- 首先你在這題應該要先做質數篩，要不然每次詢問都重找太慢了
- 用線性篩法$\mathcal O(N)$或者是先篩掉$2,3,5$優化過的埃氏篩$\mathcal O(N \log \log N)$應該都會過<!-- .element: class="fragment" data-fragment-index="1" -->
- 有人丟了$\mathcal O(NQ)$的質數判斷`TLE`，有人丟了$\mathcal O(N^2)$的質數篩也得到了<!-- .element: class="fragment" data-fragment-index="2" -->`TLE`<!-- .element: class="fragment" data-fragment-index="2" -->
- 上面兩個人是同一個<!-- .element: class="fragment" data-fragment-index="3" -->

----

### 連續xor和

- 每次詢問都$\mathcal O(R-L)$檢查一次
- TLE<!-- .element: class="fragment" data-fragment-index="1" -->
- 考慮用前綴和的想法<!-- .element: class="fragment" data-fragment-index="2" -->
- 注意到xor可以這樣搞<!-- .element: class="fragment" data-fragment-index="3" -->
- AC<!-- .element: class="fragment" data-fragment-index="4" -->

---

## (新)pJ 簡單的數學構造題！

- 題目：多次詢問一個整數$N$，構造一個互異正整數`tuple`$(x, y, z)$使得$\frac{1}{x}+\frac{1}{y}+\frac{1}{z}=\frac{2}{N-1}$，其中$x<y<z$

----

### 通分

- 沒打算講這個，大家國小就都學過了
- 出這題的原因是看計分板好像頗慘，所以出一題水題給大家寫<!-- .element: class="fragment" data-fragment-index="1" -->
- 這題的難度定位是國小資優題吧，所以沒做出來的應該檢討一下自己<!-- .element: class="fragment" data-fragment-index="2" -->

----

### 觀察

- $$
   \frac{1}{N}+\frac{1}{N-1}+\frac{1}{N(N-1)}\\ 
  =\frac{(N-1)+(N)+(1)}{N(N-1)}\\
  =\frac{2N}{N(N-1)}=\frac{2}{N-1}$$<!-- .element: class="fragment" data-fragment-index="1" -->
- 注意到$N>1$，所以最後一步的約分不會出問題<!-- .element: class="fragment" data-fragment-index="2" -->
- 注意到在$N=2$時，<!-- .element: class="fragment" data-fragment-index="3" -->$N=N(N-1)$<!-- .element: class="fragment" data-fragment-index="3" -->

---

## pK 前情侶的日常快照 「妳覺得是誰在戳」

- 題目：輸出一個id
- 這題是因為我不能接受我辛辛苦苦寫了三千多字的題目敘述出不出來才加上去的<!-- .element: class="fragment" data-fragment-index="1" -->

----

### 誠實

- 輸出`solocat`就可以AC了

----

### 統計

- 輸出`solocat`的有11人<!-- .element: class="fragment" data-fragment-index="1" -->
- 輸出`JiKuai`的有0人<!-- .element: class="fragment" data-fragment-index="1" -->
- 輸出`wh0am1`的有4人<!-- .element: class="fragment" data-fragment-index="1" -->

---

## 頒獎owo

- 我還不知道有沒有獎品就是了
- [計分板](http://csdc.tw/contest/19/rank/)

----

### 名次

|＃|名字|CSDCOJ ID|解題數|總罰時|
|:-:|:-:|:-:|:-:|:-:|
|1|潘勁諺|潘勁諺|11|899:41:27|
|2|古宗諺|nekogravitycat|9|637:16:29|
|3|郭昱增|lovemilk_1209|4|282:58:55|
|4|賴奕岑|wh0am1|4|350:22:10|
|5|柯俊安|NoterI2013|4|353:22:8|
|6|呂泰廷|Teddy|3|252:51:26|
- 前五名裡只有**郭昱增**沒有找過我~~比賴\*\*強多了~~

----

### 首殺名次

|＃|名字|CSDCOJ ID|首殺題數|題號|
|:-:|:-:|:-:|:-:|:-:|
|1|潘勁諺|潘勁諺|6|pA,pB,pD<br>pE,pF,pI|
|2|古宗諺|nekogravitycat|3|pC,pG,pH|
|3|郭昱增|lovemilk_1209|1|pJ|
||賴奕岑|wh0am1|1|pK|

----

### 非`AC`上傳次數

|＃|名字|CSDCOJ ID|次數|
|:-:|:-:|:-:|:-:|