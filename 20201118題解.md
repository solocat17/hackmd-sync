# 11/18 社內賽題解

[TOC]

---

## pA 歡迎來到竹中軟研第一次社內賽的教室 ><

**出題者:李宗諺**
- 首殺: 郭昱增(lovemilk_1209)
- 首penalty: 葉哲睿(yehray0528)

簽到題，筆者覺得正常寫法好無聊，所以就寫了三行解><

:::spoiler 程式碼
```cpp=
#include <iostream>
#include <string>
using namespace std; int main() {string AC; cin >> AC; cout << "Hello CSDC36th!\n"; return 0;}
```
:::

---

## pB 總之就是很膜拜！

**出題者:李宗諺**
- 首殺: 賴奕岑(wh0am1)
  - 總之我們先恭喜@wh0am1首殺題敘出現自己的題目 ><

1. 把$T$吃進來看有多少人 
2. 以下動作要做$T$次    $\leftarrow$有人死在這裡，咩噗咩噗
    - 判斷這人是誰
    - 如果是電神就輸出Orz，否則輸出Hi

::: spoiler 程式碼
```cpp=
#include <iostream>
#include <string>
using namespace std;

int main() {
  int t;
  cin >> t;
  string str;
  while (t--) {
    cin >> str;
    if (str == "JiKuai" || str == "Jason" || str == "wh0am1") {
      cout << str << "Orz\n";
    }
    else {
      cout << "Hi, " << str << '\n';
    }
  }
  return 0;
}
```
:::

---

## pC 拉米買蛋糕
**出題者: 某雪民**
* 首殺: 郭昱增(lovemilk_1209)

其實這題就是個a+b問題，要注意的是輸入最大可以到$2^{31}-1$，$(2^{31}-1)+(2^{31}-1)=2^{32}-2$
:::info
int的範圍為$[-2^{31}, 2^{31}-1]$
long long的範圍則為$[-2^{63}, 2^{63}-1]$
:::
會超出int範圍，造成```overflow```，解決辦法就是使用強制轉型讓他變成long long，或者一開始的變數就直接宣告成long long也可以。
:::spoiler 程式碼
```cpp
#include <iostream>
using namespace std;

int main() {
	int t;
	cin >> t;
	while(t--) {
		int a, b;
		cin >> a >> b;
		cout << (long long) a + b << endl;
	}
}
```
:::

---

## pD 又又又又又輸了

**出題者:李宗諺**
* 首殺: 郭昱增(lovemilk_1209)

我們可以只存<ruby>**我妹妹**<rt>**深雪ちゃん**</rt></ruby>的魔法力，之後每次吃進莉娜的魔法力就和**我妹妹**的比較誰大誰小，不斷更新莉娜總共會輸幾次

:::spoiler 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() {
  int d, ans = 0, lina, imouto[100];
  cin >> d;
  for (int i = 0; i < d; i++) cin >> imouto[i];
  for (int i = 0; i < d; i++) {
    cin >> lina;
    if (lina <= imouto[i]) ans++;
  }
  cout << ans << '\n';
}
```
:::

---

## pE 全婆俠的正宮
**出題者:陳泰穎**
* 首殺: 賴奕岑(wh0am1)

### sol.1
去假設每個人是正宮，再去檢查除了他以外的所有人是不是愛好程度都比較小，是的話就是答案了
:::spoiler 程式碼
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
	int n;
	cin >> n;
	string name[n];
	int love[n];
	for(int i = 0; i < n; i++) {
		cin >> name[i] >> love[i];
	}
	for(int i = 0; i < n; i++) {
		bool is_ans = true;
		for(int j = 0; j < n; j++) {
			if(i != j && love[j] > love[i]) {
				is_ans = false;
			}
		}
		if(is_ans) {
			cout << name[i] << endl;
		}
	}
}
```
:::
### sol.2
可以開兩個變數，分別代表:目前記錄到最大的愛好程度及那個人的名字
然後不斷更新這兩個變數
:::spoiler 程式碼
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
	int n;
	cin >> n;
	string ans, name;
	int cur_max_love = 0, love;
	for(int i = 0; i < n; i++) {
		cin >> name >> love;
		if(love > cur_max_love) {
			cur_max_love = love;
			ans = name;
		}
	}
	cout << ans << endl;
}
```
:::

---

## pF 城市觀測
**出題者:陳泰穎**
* 首殺: 潘勁諺

### sol.1
對於每個大樓去看他前面有沒有大樓比他高或跟他一樣高
:::spoiler 程式碼
```cpp
#include <iostream>
using namespace std;

int main() {
	int n;
	cin >> n;
	int arr[n];
	for(int i = 0; i < n; i++) {
		cin >> arr[i];
	}
	for(int i = 0; i < n; i++) {
		bool is_ans = true;
		for(int j = 0; j < i; j++) {
			if(arr[j] >= arr[i]) {
				is_ans = false;
			}
		}
		if(is_ans) {
			cout << i + 1 << " ";
		}
	}
}
```
:::
### sol.2
跟上一題差不多
可以直接開個變數紀錄在他之前的所有大樓最大高度，就可以只檢查最大高度是否大於等於當前的大樓
:::spoiler 程式碼
```cpp
#include <iostream>
using namespace std;

int main() {
	int n;
	cin >> n;
	int input;
	int cur_max_height = 0;
	for(int i = 1; i <= n; i++) {
		cin >> input;
		if(cur_max_height < input) {
			cout << i << " ";
			cur_max_height = input;
		}
	}
}
```
:::

---

## pG 擔心哥哥的優等生

**出題者:李宗諺**
- 首殺: 郭昱增(lovemilk_1209)

~~根據可靠情報指出，這題重點在於看完題目~~
解題關鍵:
1. 題目太長可以先看輸入輸出敘述
2. 題目太長猜重點在後半段
3. 看到看不懂的敘述可以猜說他大概和解題重點無關，可以考慮先略過，最後如果發現看不懂要幹嘛再回來看
4. 圖片就算很香也不要停在那邊只顧著舔螢幕(X)

:::spoiler 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() {
  int t, d, l, a, b, mx;
  cin >> t;
  while (t--) {
    cin >> d >> l >> a >> b;
    mx = d * a + b;
    if (mx >= l) cout << "MIYUKI's DAY!\n";
    else cout << "HATARAKU DAY!\n";
  }
  return 0;
}
```
:::

---

## pH 兩點間距離

**出題者:黃晴威 & 備題者:陳泰穎**
- 首殺: 郭昱增(lovemilk_1209)

兩點間距離為
$\quad$ $$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$
可以對兩邊平方，只要檢查:
$\quad$ $$(x_1-x_2)^2+(y_1-y_2)^2>k^2$$

:::spoiler 程式碼
```cpp=
#include <iostream>
using namespace std;

int main() {
	int n, k;
	cin >> n >> k;
	int x[n], y[n];

	for(int i = 0; i < n; i++) {
		cin >> x[i] >> y[i];
	}
	bool ok = false;
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			int dx = x[i] - x[j];
			int dy = y[i] - y[j];
			if(dx * dx + dy * dy > k * k) {
				ok = true;
			}
		}
	}
	if(ok) {
		cout << "Yes" << endl;
	}
	else {
		cout << "No" << endl;
	}
}
```
:::
**插曲**: 某人只檢查$|x-y|$是否大於k，然後差點過了所有測資(他只差範測沒過，還敢不測試範測R)
![](https://i.imgur.com/bUZnxqf.png)

---

## pI 在軟研社說早安

**出題者:李宗諺**
- 首殺:*滅台嗚嗚嗚*

- 觀察之後可以發現$2\times 3$和$1\times 6$的矩形可以組合出所有邊長是整數，面積是6的倍數的矩形

![](https://i.imgur.com/N97sLNe.png =50%x)

- 之後就好好枚舉所有$r\in \{r|1\leq r \leq \sqrt{6\times K}, r\in \mathbb{N} \}$，可以找出對應的$i, j$，枚舉細節放在底下程式碼
  - $r$在底下的程式碼是以`enmr`表示

:::spoiler 程式碼
```cpp=
#include <iostream>
#include <algorithm>  //swap()
using namespace std;

int main() {
  long long int m, n, k, ans = 9223372036854775807; //long long max
  cin >> k >> m >> n;
  k *= 6;
  if (m > n) swap(m, n);   //拿小的來枚舉
  for (long long enmr = 1, i, j; enmr * enmr <= k; enmr++) {  
    i = enmr;  
    j = (k + enmr - 1) / enmr;  //求一個枚舉的enmr對應的i對應的j
    if (i > j) break;     //因為m < n，所以在m > n時就可以離開迴圈
    if (i < m) i = m;     //只考慮i至少為m的狀況
    if (j < n) j = n;     //只考慮j至少為n的狀況
    if (i * j < ans) ans = i * j;  //算目前的面積
  }
  cout << ans << endl;
  return 0;
}
```
:::

---

## pJ 在館山基地說早安

**出題者:李宗諺**
- 首殺:*滅台嗚嗚嗚*
$\quad$
- 考慮每次都做一次質數篩最多會做到10次，不太開心，我們可以在一開始先做一次質數篩，考慮$n<1000$原則上$O(n^2)$都會過(不會複雜度可以不用理這句)
- 做完質數篩之後直接三層迴圈枚舉炸開，如果和是對的就輸出出來

:::spoiler 程式碼
```cpp=
#include <iostream>
#include <cstring>  //memset()
using namespace std;

int main() {
  int t, n;
  bool flag = 1;
  bool prime[1000];  //質數陣列，如果i是質數則prime[i-1]為1
  memset(prime, 0, sizeof(prime));  //和fill(prime, prime + 1000, 0)效果一樣
  for (int i = 3; i < 1001; i++) {
    for (int j = 2; j < i; j++) {
      if (i % j == 0) {
        flag = 0;
        break;
      }
    }
    if (flag) prime[i - 1] = 1;
    else prime[i - 1] = 0;
    flag = 1;
  }  //質數篩結束
  cin >> t;
  while (t--) {
    cin >> n;
    for (int i = 0; i < 1000; i++) {
      if (prime[i] == 0) continue;
      for (int j = 0; j < 1000; j++) {
        if (prime[j] == 0) continue;
        for (int k = 0; k < 1000; k++) {
          if (prime[k] == 0) continue;
          if ((i + j + k + 3) == n) {
            cout << i + 1 << ' ' << j + 1 << ' ' << k + 1 << endl;
            flag = 0;
            break;
          }
        }
        if (!flag) break;
      }
      if (!flag) break;
    }
    flag = 1;
  }
  return 0;
}
```
:::

- 因為還沒教過vector，所以只能用這種蹩腳寫法，要不然code可以乾淨很多的...

:::spoiler 程式碼
```cpp=
#include <iostream>
#include <vector>
using namespace std;

int main() {
  int t, n;
  vector<int> vec;
  bool flag = 1;
  for (int i = 3; i < 1001; i++) {
    for (int j = 2; j < i; j++) {
      if (i % j == 0) {
        flag = 0;
        break;
      }
    }
    if (flag) vec.push_back(i);
    flag = 1;
  }
  cin >> t;
  while (t--) {
    cin >> n;
    for (int i : vec) {
      for (int j : vec) {
        for (int k : vec) {
          if (i + j + k == n) {
            cout << i << ' ' << j << ' ' << k << endl;
            flag = 0;
            break;
          }
        }
        if (!flag) break;
      }
      if (!flag) break;
    }
    flag = 1;
  }
  return 0;
}
```
:::

---

## pK 區間加值，區間求和
**出題者: 陳泰穎**
- 首殺: 葉哲睿(yehray0528)
  - 咩噗 被假解過 他沒開long long啦QQ

~~有沒有人這題砸線段樹的~~
注意到我們總是詢問整個序列的總和
所以每次對l, r加值其實都只是給總和增加(r - l + 1)
可以直接紀錄總和
:::spoiler 程式碼
```cpp
#include <iostream>
using namespace std;

int main() {
	int n, q;
	cin >> n >> q;
	long long ans = 0;
	while(q--) {
		int type;
		cin >> type;
		if(type == 1) {
			int l, r;
			cin >> l >> r;
			ans += (r - l + 1);
		}
		else {
			cout << ans << endl;
		}
	}
}
```
:::
*****
*****
*****
*****
:::spoiler ~~為了證明線段樹還是能ac 這裡附上線段樹的ac code~~(很毒 沒事別進來)
```cpp
#include <iostream>
using namespace std;

using ll = int64_t;
const int N = 1e5 + 25;
struct segtree {
	ll arr[N << 1], tag[N];
	int n;
	void init(int _n) { n = _n; }
	void upd(int p, int v, int h) {
		arr[p] += v << h;
		if(p < n)
			tag[p] += v;
	}
	void push(int p) {
		for(int h = __lg(p); ~h; h--) {
			int i = p >> h;
			upd(i, tag[i >> 1], h);
			upd(i ^ 1, tag[i >> 1], h);
			tag[i >> 1] = 0;
		}
	}
	void pull(int p) {
		for(int h = 1; p > 1; p >>= 1, h++) {
			arr[p >> 1] = arr[p] + arr[p ^ 1] + (tag[p >> 1] << h);
		}
	}
	void edt(int l, int r, int v) {
		int tl = l + n, tr = r + n - 1, h = 0;
		push(tl); push(tr);
		for(l += n, r += n; l < r; l >>= 1, r >>= 1, h++) {
			if(l & 1)
				upd(l++, v, h);
			if(r & 1)
				upd(--r, v, h);
		}
		pull(tl);
		pull(tr);
	}
	ll que(int l, int r) {
		int tl = l + n, tr = r + n - 1;
		push(tl); push(tr);
		ll res = 0;
		for(l += n, r += n; l < r; l >>= 1, r >>= 1) {
			if(l & 1)
				res += arr[l++];
			if(r & 1)
				res += arr[--r];
		}
		return res;
	}
} tree;

int main() {
	int n, q;
	cin >> n >> q;
	tree.init(n);
	while(q--) {
		int t, a, b;
		cin >> t;
		if(t == 1) {
			cin >> a >> b;
			tree.edt(a - 1, b, 1);
		}
		else
			cout << tree.que(0, n) << endl;
	}
}

```
:::

---

## special
* 最多首殺: 郭昱增(lovemilk_1209)
* 首CE: 葉哲睿(yehray0528)
* 假解: 葉哲睿(yehray0528)
* 最後一個上傳: 蔡承佑(cytsai1008)
* 尾AC: 陳郁翔(Sean)
* 整場比賽有`307`筆submission

---

## 頒獎

### 前五名有~~老茶剩下的~~零食

[計分板連結](http://csdc.tw/contest/18/rank/)

|名次|名字|CSDCOJ ID|解題數<br>(總:11)|總罰時|
|:-:|:-:|:-:|:-:|:-:|
|1|潘勁諺|潘勁諺|8|4:52:40|
|2|葉哲睿|yehray0528|8|7:30:16|
|3|郭昱增|lovemilk_1209|7|6:5:48|
|4|許景皓|simon_0x0|6|3:41:2	|
|5|古宗諺|nekogravitycat|6|4:4:29|

***恭喜以上電神Orz***

### 首殺最多的有~~不知道哪屆學長留下來的~~徽章

|名次|名字|CSDCOJ ID|首殺題數|題號|
|:-:|:-:|:-:|:-:|:-:|
|1|郭昱增|lovemilk_1209|5|pA, pC, pD, pG, pH|
|2|賴奕岑|wh0am1|2|pB, pE|
||*滅台*|*(none)*|2|pI, pJ|
|4|潘勁諺|潘勁諺|1|pF|
||葉哲睿|yehray0528|1|pK|

***恭喜以上電神Orz***

### 解超過一半題數的各位裡吃最少次錯誤上傳的也有徽章

|名次|名字|CSDCOJ ID|吃幾次非`AC`|
|:-:|:-:|:-:|:-:|
|1|潘勁諺|潘勁諺|2|
|2|許景皓|simon_0x0|5|
|3|郭昱增|lovemilk_1209|6|
||古宗諺|nekogravitycat|6|
|5|葉哲睿|yehray0528|9|
|6|陳郁翔|Sean|15|

***恭喜以上電神Orz***

---

## 連結

#### 社內賽回饋

#### https://forms.gle/sWwrj6Cne8ELtqX57

![](https://i.imgur.com/AEGGfz2.png)

#### 題解網址

#### https://hackmd.io/@solocat/SJbEV7hKw

![](https://i.imgur.com/3TFI961.png)

